<!doctypehtml><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Filipe Laíns - Python, Debian, and the install locations</title><meta content="2021-09-29 02:30:00"property=article:published_time><meta content=2024-07-22T00:56:44.457718 property=article:modified_time><link href=../../static/css/style.css rel=stylesheet><link href=../../static/css/pygments.css rel=stylesheet><body><section class=section><div class=container><nav aria-label="main navigation"class="navbar is-transparent pb-3"role=navigation><div class=navbar-brand><a class=navbar-item href=https://ffy00.github.io> <h1 class=title>Filipe Laíns</h1> </a><a aria-expanded=false aria-label=menu class=navbar-burger data-target=main-navbar role=button> <span aria-hidden=true></span> <span aria-hidden=true></span> <span aria-hidden=true></span> </a></div><div class=navbar-menu id=main-navbar><div class=navbar-end><a class=navbar-item href=../..>Home</a><a class=navbar-item href=../../blog>Blog</a></div></div></nav><h1 class="title has-text-centered">Python, Debian, and the install locations</h1><h1 class="subtitle has-text-centered">02:30 29/09/2021</h1><div class=content><section class=content id=introduction><h1 class=title>Introduction</h1><p>Today, I will be talking about the Debian patching of Python, more specifically, the Debian patching of the Python install locations and interpreter initialization in specific.<p>As some of you may know, the Python shipped by Debian is not exactly the same Python as the Python core developers intended. Debian makes several intrusive changes the Python distribution they ship. You can check the <a href=https://www.debian.org/doc/packaging-manuals/python-policy/index.html#document-interpreter>Debian policy on Python packaging</a> for details.<p>Distributors modifying software is not unheard of, in fact, it is fairly common. It is sometimes required to get software to work properly on the target system. However, generally, these modifications are kept fairly minimal. That is not the case of the Debian Python, which has significant behavior discrepancies from normal Python installations, and ends up resulting in issues and lots of frustration per part of the users and developers that have to deal with it. The last effort in documenting this negative impact that I am aware of is <a href=https://gist.github.com/tiran/2dec9e03c6f901814f6d1e8dad09528e>this gist</a> by Christian Heimes (tiran).</section><section class=content id=patched-behavior-and-motivation><h1 class=title>Patched behavior and motivation</h1><div class="message is-warning"><div class=message-header><p>Disclaimer</div><div class=message-body><p>Please note that what I am about to describe here is to best of my knowledge the motivation from what I have discussed with people, but I may still be missing context and/or have forgotten things, so please take it with a grain of salt. If it is not accurate, please reach out to me and I will either update this post or make a new one and link it here.</div></div><p>Okay, let's take a look at what behavior Debian actually patches and why they do it.<p>A normal Python installation to the <code>/usr</code> prefix will have a site packages directory at <code>/usr/lib/pythonX.Y/site-packages</code>. The site packages directory is a place for user-installed packages, it is a mechanism that that Python us to customize the default environment of the interpreter. That means packages installed there will be available in the interpreter, so you will be able to import them. This functionality is provided by the <code>site</code> module, and can be disabled by passing the <code>-S</code> option to the interpreter.<p>Install locations on Linux are governed by the <a href=https://refspecs.linuxfoundation.org/FHS_3.0/fhs.html>Filesystem Hierarchy Standard (FHS)</a> specification, at least in the distributions that adopt it, which are most of them, including Debian. It describes what each location on the system means and how files are distributed. The bits relevant for us are the <code>/usr</code> and <code>/usr/local</code> paths. I am not gonna get into many details, but essentially <code>/usr</code> and <code>/usr/local</code> contain our program data, split into subdirectories as specified by the <a href=https://refspecs.linuxfoundation.org/FHS_3.0/fhs.html#theUsrHierarchy>/usr hierarchy</a> page, with <code>/usr</code> being reserved for the software installed by system vendor, and <code>/usr/local</code> for software installed locally by the system administrator (generally, the user).<p>The <a href=https://refspecs.linuxfoundation.org/FHS_3.0/fhs.html#usrlocalLocalHierarchy>/usr/local hierarchy</a> pages says as follows:<blockquote><p>The /usr/local hierarchy is for use by the system administrator when installing software locally. It needs to be safe from being overwritten when the system software is updated. It may be used for programs and data that are shareable amongst a group of hosts, but not found in /usr.<p>Locally installed software must be placed within /usr/local rather than /usr unless it is being installed to replace or upgrade software in /usr.</blockquote><p>Which Debian understands to be the case of Python packages installed by pip. I do not agree with that interpretation, because what we are doing when installing Python packages via pip is customizing our Python installation. Now, I will acknowledge that the line is fuzzy as some users use a pip as a way to installing software without intending to customize the default environment of the Python interpreter, but at the end of the day, they are still customizing the Python environment.<p>I think the following makes it clear that data installed to <code>/usr/local</code> should not be used for programs in <code>/usr</code>.<blockquote><p>It may be used for programs and data that are shareable amongst a group of hosts, but not found in /usr.</blockquote><p>But alas, Debian thinks pip should place packages in <code>/usr/local</code>, reserving <code>/usr</code> for the Python packages installed by Debian. This would mean <code>/usr/lib/pythonX.Y/site-packages</code> for Debian packages, and <code>/usr/local/lib/pythonX.Y/site-packages</code> for packages installed by pip. The more attentive of you might have spotted the first problem, using <code>/usr/local/lib/pythonX.Y/site-packages</code> conflicts with local Python installations, which use the <code>/usr/local</code> prefix! Both <code>/usr/bin/python</code> and <code>/usr/local/bin/python</code> would be loading packages from <code>/usr/local/lib/pythonX.Y/site-packages</code>. For this reason, Debian renamed <code>site-packages</code> to <code>dist-packages</code> in their Python.<p>They also remove the Python minor version from the install path for their packages, making it <code>/usr/lib/pythonX/dist-packages</code>. This is done to avoid rebuilding all packages that contain Python modules when Python is updated.<p>So summarizing, Debian removes <code>/usr/lib/pythonX.Y/site-packages</code> from the module import path search list (<a href=https://docs.python.org/3/library/sys.html#sys.path>sys.path</a>), adds <code>/usr/lib/pythonX/dist-packages</code> and <code>/usr/local/lib/pythonX.Y/dist-packages</code>, and changes the default install location to <code>/usr/local/lib/pythonX.Y/dist-packages</code> (well, only in one place, but I am getting ahead of myself, we will have a look at this later).</section><section class=content id=how-is-it-patched><h1 class=title>How is it patched?</h1><p>Before looking at the details of how the patching is done, we need some background on the following standard library modules.<dl class="box has-background-success-light"><dt><a href=https://docs.python.org/3/library/distutils.html>distutils</a><dd><code>distutils</code> is a standard library module for building and installing Python packages. It is the predecessor for setuptools, which extends it (well, that is not technically 100% correct, but to avoid complicating things, you can understand it as so). <code>distutils</code> is deprecated and will be removed in Python 3.12.<dt><a href=https://docs.python.org/3/library/sysconfig.html>sysconfig</a><dd><code>sysconfig</code> is a standard library module that provides access to the Python installation configuration details, like installation paths and configuration variables.<dt><a href=https://docs.python.org/3/library/site.html>site</a><dd><code>site</code> is a module that is automatically imported during the interpreter initialization and adds user customizations, like providing access to user installed modules. It can be disabled by passing <code>-S</code> to the Python interpreter.</dl><p>So, what exactly does Debian do to achieve their desired behavior?<p>Debian applies several patches to the Python install they distribute, which can be found <a href=https://salsa.debian.org/cpython-team/python3/-/tree/master/debian/patches>here</a>, but the relevant one for us is <a href=https://salsa.debian.org/cpython-team/python3/-/blob/master/debian/patches/distutils-install-layout.diff>distutils-install-layout.diff</a>.<p>The patch adds two new install schemes to <code>distutils.command.install.INSTALL_SCHEMES</code>, <code>deb_system</code> and <code>unix_local</code>, overwrites the prefix selection logic in <code>distutils</code> to use them, and overwrites the site packages paths in the <code>site</code> module to use their desired paths instead of the default one.<p>There's also a <a href=https://salsa.debian.org/cpython-team/python3/-/blob/master/debian/patches/sysconfig-debian-schemes.diff>sysconfig-debian-schemes.diff</a> patch that adds the new install schemes to <code>sysconfig</code> in the repo, but <strong>they do not apply it</strong>.</section><section class=content id=the-issue><h1 class=title>The issue</h1><p>As we saw above, Debian overwrites the site packages in paths in the <code>site</code> module, however, they do not patch <code>sysconfig</code> to represent those modifications, only <code>distutils</code>. This presents a really big problem, the install locations returned by <code>sysconfig</code> are incorrect.<pre data-language=python><span class=o>>>></span> <span class=kn>import</span> <span class=nn>sysconfig</span>
<span class=o>>>></span> <span class=n>sysconfig</span><span class=o>.</span><span class=n>get_paths</span><span class=p>()</span>
<span class=p>{</span><span class=s1>'stdlib'</span><span class=p>:</span> <span class=s1>'/usr/lib/python3.8'</span><span class=p>,</span>
 <span class=s1>'platstdlib'</span><span class=p>:</span> <span class=s1>'/usr/lib/python3.8'</span><span class=p>,</span>
 <span class=s1>'purelib'</span><span class=p>:</span> <span class=s1>'/usr/lib/python3.8/site-packages'</span><span class=p>,</span>
 <span class=s1>'platlib'</span><span class=p>:</span> <span class=s1>'/usr/lib/python3.8/site-packages'</span><span class=p>,</span>
 <span class=s1>'include'</span><span class=p>:</span> <span class=s1>'/usr/include/python3.8'</span><span class=p>,</span>
 <span class=s1>'platinclude'</span><span class=p>:</span> <span class=s1>'/usr/include/python3.8'</span><span class=p>,</span>
 <span class=s1>'scripts'</span><span class=p>:</span> <span class=s1>'/usr/bin'</span><span class=p>,</span>
 <span class=s1>'data'</span><span class=p>:</span> <span class=s1>'/usr'</span><span class=p>}</span></pre><p>So, installers will get locations that have absolutely no effect on the interpreter. The bigger problem though, is that Debian is so widely used that this forces them to implement workarounds or add custom logic for Debian, but this is not straightforward and requires knowledge of most of the quirks explained in this post to be implemented correctly. This has been the source of much frustration for lots of people, myself included.</section><section class=content id=i-am-stuck-with-it-what-do-i-do><h1 class=title>I am stuck with it, what do I do?</h1><p>In the unfortunate case you have to deal with this, well, you will have to load the install locations from <code>distutils</code>, which, as I mentioned above, is deprecated and will be removed in Python 3.12.<pre data-language=python><span class=kn>import</span> <span class=nn>distutils.dist</span>

<span class=n>distribution</span> <span class=o>=</span> <span class=n>distutils</span><span class=o>.</span><span class=n>dist</span><span class=o>.</span><span class=n>Distribution</span><span class=p>({</span>
    <span class=s1>'name'</span><span class=p>:</span> <span class=s1>'some-python-package'</span><span class=p>,</span>
<span class=p>})</span>
<span class=n>install_cmd</span> <span class=o>=</span> <span class=n>distribution</span><span class=o>.</span><span class=n>get_command_obj</span><span class=p>(</span><span class=s1>'install'</span><span class=p>)</span>
<span class=n>install_cmd</span><span class=o>.</span><span class=n>finalize_options</span><span class=p>()</span>

<span class=n>locations</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s1>'data'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_data</span><span class=p>,</span>
    <span class=s1>'headers'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_headers</span><span class=p>,</span>
    <span class=s1>'platlib'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_platlib</span><span class=p>,</span>
    <span class=s1>'purelib'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_purelib</span><span class=p>,</span>
    <span class=s1>'scripts'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_scripts</span><span class=p>,</span>
<span class=p>}</span></pre><p>But wait, you can't. You cannot assume <code>distutils</code> is there! Debian partially splits the <code>distutils</code> module, which is part of the standard library and should be available on all Python installations. The user must have the <code>python3-distutils</code> package installed. One last thing to keep in mind, the <code>distutils</code> module is only partially split, so <code>import distutils</code> will work, but importing any submodule other than <code>distutils.version</code> will not.<p>Debian does not add any custom logic here to raise an exception with a descriptive error message asking the user to install <code>python3-distutils</code>, like they do with some of the other modules they split from the <code>python3</code> package, so you probably want to do that yourself.<pre data-language=python><span class=k>try</span><span class=p>:</span>
    <span class=kn>import</span> <span class=nn>distutils.dist</span>
<span class=k>except</span> <span class=ne>ModuleNotFoundError</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
    <span class=k>raise</span> <span class=ne>ModuleNotFoundError</span><span class=p>(</span>
        <span class=s1>'No module named distutils.dist. Please make sure you have '</span>
        <span class=s1>'python3-distutils installed if you are on a Debian system.'</span>
    <span class=p>)</span> <span class=kn>from</span> <span class=kc>None</span></pre><p>And this gets worse if you actually want to install to the system, which you might if you are a build system that supports building Python modules (eg. Meson). In which case, you will want to set the <code>install_layout</code> option to <code>deb</code>, <code>install_layout</code> being an option added by Debian in their patching.<pre data-language=python><span class=k>try</span><span class=p>:</span>
    <span class=kn>import</span> <span class=nn>distutils.dist</span>
<span class=k>except</span> <span class=ne>ModuleNotFoundError</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
    <span class=k>raise</span> <span class=ne>ModuleNotFoundError</span><span class=p>(</span>
        <span class=s1>'No module named distutils.dist. Please make sure you have '</span>
        <span class=s1>'python3-distutils installed if you are on a Debian system.'</span>
    <span class=p>)</span> <span class=kn>from</span> <span class=kc>None</span>

<span class=kn>import</span> <span class=nn>distutils.command.install</span>

<span class=n>distribution</span> <span class=o>=</span> <span class=n>distutils</span><span class=o>.</span><span class=n>dist</span><span class=o>.</span><span class=n>Distribution</span><span class=p>({</span>
    <span class=s1>'name'</span><span class=p>:</span> <span class=s1>'some-python-package'</span><span class=p>,</span>
<span class=p>})</span>
<span class=n>install_cmd</span> <span class=o>=</span> <span class=n>distribution</span><span class=o>.</span><span class=n>get_command_obj</span><span class=p>(</span><span class=s1>'install'</span><span class=p>)</span>
<span class=k>if</span> <span class=s1>'deb_system'</span> <span class=ow>in</span> <span class=n>distutils</span><span class=o>.</span><span class=n>command</span><span class=o>.</span><span class=n>install</span><span class=o>.</span><span class=n>INSTALL_SCHEMES</span><span class=p>:</span>  <span class=c1># Debian distutils</span>
    <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_layout</span> <span class=o>=</span> <span class=s1>'deb'</span>
<span class=n>install_cmd</span><span class=o>.</span><span class=n>finalize_options</span><span class=p>()</span>

<span class=n>locations</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s1>'data'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_data</span><span class=p>,</span>
    <span class=s1>'headers'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_headers</span><span class=p>,</span>
    <span class=s1>'platlib'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_platlib</span><span class=p>,</span>
    <span class=s1>'purelib'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_purelib</span><span class=p>,</span>
    <span class=s1>'scripts'</span><span class=p>:</span> <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_scripts</span><span class=p>,</span>
<span class=p>}</span></pre><p>That is, of course, if you want to install to the system. Most of the times, you actually want to install to whichever install scheme is currently active. So we need to check if distutils is currently picking the <code>deb_system</code> layout. The easiest way I found of checking this is by looking at the value of <code>distutils.sysconfig.get_python_lib()</code>, see <a href=https://salsa.debian.org/cpython-team/python3/-/blob/python3.6/debian/patches/distutils-install-layout.diff#L140>the relevant bit of distutils-install-layout.diff</a>. If it ends in <code>dist-packages</code>, we are using the <code>deb_system</code> scheme, otherwise we are using the normal one. So, the code above becomes:<pre data-language=python><span class=o>...</span>

<span class=k>if</span> <span class=p>(</span>
    <span class=s1>'deb_system'</span> <span class=ow>in</span> <span class=n>distutils</span><span class=o>.</span><span class=n>command</span><span class=o>.</span><span class=n>install</span><span class=o>.</span><span class=n>INSTALL_SCHEMES</span>
    <span class=ow>and</span> <span class=n>distutils</span><span class=o>.</span><span class=n>sysconfig</span><span class=o>.</span><span class=n>get_python_lib</span><span class=p>()</span><span class=o>.</span><span class=n>endswith</span><span class=p>(</span><span class=s1>'dist-packages'</span><span class=p>)</span>
<span class=p>):</span>  <span class=c1># Debian distutils</span>
    <span class=n>install_cmd</span><span class=o>.</span><span class=n>install_layout</span> <span class=o>=</span> <span class=s1>'deb'</span>

<span class=o>...</span></pre><p>And what about Python 3.12 and after? Well, I don't know. The correct answer ignoring Debian would be to simply use <code>sysconfig.get_paths()</code>. Our issue is that we don't really know what Debian will do, and how exactly they will patch Python. My best guess is that they will patch <code>sysconfig</code>, as they should be already, and that we will finally be able to rely on it (after 10 years of it being in the standard library!).</section><section class=content id=how-to-fix-it><h1 class=title>How to fix it?</h1><p>Well, the solution seems fairly straightforward to me. Debian should patch <code>sysconfig</code> to reflect their changes to the <code>site</code> module initialization.<p>The necessary patching would be adding the <code>deb_system</code> and <code>unix_local</code> install schemes, and overwriting <code>sysconfig._get_preferred_schemes()</code> to select <code>unix_local</code>.</section><section class=content id=conclusion><h1 class=title>Conclusion</h1><p>Well, you now probably understand why the first thing most people tell you when starting in Python development is to forget about your distro-provided Python, and install it from source or use something like <a href=https://github.com/pyenv/pyenv>pyenv</a>. The Python installation that Debian, and virtually all Debian-based distros, are distributing is effectively broken.<p>What makes this worse is that this is just one of the multiple issues with the patching Debian does to the Python installation they distribute. This has been a massive pain point for years, and not much has been done about this. I truly believe it has tarnished both Debian and Python's reputations, such to a degree that some have suggested that the <a href=https://www.python.org/psf/>PSF</a> should take up this issue and ask Debian to either fix their Python distribution or rename it, because the Python Debian is shipping is effectively not the Python released by developers. This sounds very harsh, but honestly, I cannot blame them – this is has been a real issue for years and nothing has been done about it.<p>I do not blame the Debian Python maintainer though, the details we discussed here are very complex and there are many things to take into account, which are rarely obvious. I would say the issue is the lack of a Debian policy to address these situations, if Debian has policies that force the maintainers to make such invasive modifications to software, they should require a discussion to be started with the project upstream asking for guidance and recommendations on how to achieve the desired behavior, to minimize the negative impact the downstream patching will have.<p>That said, I think the Python upstream should strive to make the situation better for downstream packagers. We have seen that vendors have certain needs that are not being addressed, so we should try to fix that. I took a stab at solving this with <a href=https://bugs.python.org/issue43976>bpo-43976</a> and <a href=https://bugs.python.org/issue44982>bpo-44982</a>, but progress has been slow. The idea is that the Python upstream should provide a way for vendors to customize certain aspects of the distribution, like the install locations, and a way to identify custom Python distributions.<div class="message is-info"><div class=message-header><p>Edited on 17-10-2021</div><div class=message-body><ul><li>Added link to Debian policy<li>Added details about how to identify the currently active install scheme in Debian</ul></div></div></section></div></div></section></body><script src=../../static/js/bulma-navbar.js></script>